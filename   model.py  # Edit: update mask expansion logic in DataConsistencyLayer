def real_to_complex(tensor):
    return tensor[..., 0] + 1j * tensor[..., 1]

class DataConsistencyLayer:
    def __init__(self, weight=1.0):
        self.weight = weight

    def forward(self, predicted_kspace, measured_kspace, mask):
        if predicted_kspace.shape[-1] == 2:
            pred_complex = real_to_complex(predicted_kspace)
            meas_complex = real_to_complex(measured_kspace)
        else:
            pred_complex = predicted_kspace
            meas_complex = measured_kspace

        if mask.dim() == 2:
            mask = mask.unsqueeze(0).unsqueeze(0)
            mask = mask.expand(pred_complex.shape[0], pred_complex.shape[1], -1, -1)
        elif mask.dim() == 3:
            mask = mask.unsqueeze(1)
            mask = mask.expand(-1, pred_complex.shape[1], -1, -1)
        elif mask.dim() == 4:
            mask = mask.expand(-1, pred_complex.shape[1], -1, -1)

        if pred_complex.shape[2] != mask.shape[2]:
            raise RuntimeError("Dimension mismatch between predicted_kspace and mask.")
        
        dc_kspace = pred_complex * (1 - mask) + meas_complex * mask * self.weight + pred_complex * mask * (1 - self.weight)
        return dc_kspace